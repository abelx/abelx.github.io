<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Abelx's Blog</title>
    <description>New blog, just to record. # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 26 Jul 2017 22:49:00 +0800</pubDate>
    <lastBuildDate>Wed, 26 Jul 2017 22:49:00 +0800</lastBuildDate>
    <generator>Jekyll v3.5.0</generator>
    
      <item>
        <title>从Python2麻烦的编码说起</title>
        <description>&lt;h2 id=&quot;关于编码&quot;&gt;关于编码&lt;/h2&gt;
&lt;p&gt;编码应该是通信领域的研究内容。因为计算机能处理的只有二进制数值型的数据，所以信息要编码成二进制表示才能进行处理、传输和存储。&lt;/p&gt;
&lt;h3 id=&quot;ascii码gbk和unicode&quot;&gt;ASCII码，GBK和Unicode&lt;/h3&gt;
&lt;p&gt;最简单常见的字符编码应该就是ASCII码，它把英文26个字母的大小写和一些特殊符号编码在一个字节里，基本上可以表示英文中的所有符号了。但是一个字节只有八个bit，只能表示256个符号，像中文，日语，汉语等语言的文字远远不止256个，想要表示中文就需要一种新的编码。因此，GBK编码应运而生。关于GBK和GB2312等的区别和联系这里不谈，统一称为GBK编码。中国的一些学者和机构意识到为了方便计算机处理中文需要提出一种统一的编码标准GBK，它用两个字节编码了几乎全部的中文文字符号，同时也保留了ASCII码的符号。但是GBK是我们自己制定的编码标准，并不是一种国际标准。如果汉语有一套编码，日语有一套编码，阿拉伯语也有一套编码，那不就乱套了吗，也加重了计算机处理文本的复杂度。所以，为了实际和平，Unicode站了出来。Unicode有两字节，四字节等等，这应该和他需要编码的信息量有关系。可以仅仅把Unicode的码字简单的当成是一个整数，一个符号对应一个整数。他也保留了ASCII码的全部码字，而且对应的数值都完全一致，ASCII码要转换成Unicode只需要拷贝低字节高字节补零就行了。现在，世界看上去非常美好了，所有的文字符号都能在Unicode中占有一席之地，对一篇文档编码也只需要查一下编码表，然后分配固定的空间（2or3字节）填上值就行了。但是，坏就坏在了这个“固定”上了。本来一个字节就可以编码的英文字母，现在为了迁就其他语言的文字符号也要用四个字节来表示，这对于英文为主的文档大大增加了存储空间的开销，也增加了传输的复杂度。所以，需要一种新的编码方式把这些数值化的信息再进行编码，使其既方便计算机处理又相对节省存储空间，这就是UTF-8，UTF-16等编码的历史使命。为了达到压缩目的，显然需要一种变长的编码方式，像霍夫曼编码等。具体怎么进行编码才能在保存信息量又尽可能的压缩存储空间就是编码理论需要研究的了。&lt;/p&gt;

&lt;p&gt;既然UTF-8才是顺应历史发展的潮流，而且国际通用，那么在中文编码中为什么GBK还是如此常见呢？思考一个问题，UTF-8解决的主要问题是什么？节省存储空间。那么如果有一个编码能完美的编码中英文文档又更加节省空间，那么你要不要用呢？GBK就可以做到，因为它没有肩负着“编码全世界”的重担，而且它是专门针对中文的编码，所以他能以一种更节省空间的方式编码中文。比如UTF-8一个中文字符需要三个字节，而GBK只需要两个字节。这种提高在TB甚至PB级的数据量上所能节省的存储空间是非常客观的。我想，这也是我在实习的时候处理的数据都是GBK编码的原因吧。&lt;/p&gt;

&lt;h2 id=&quot;python2的编码问题&quot;&gt;Python2的编码问题&lt;/h2&gt;
&lt;p&gt;听说Python3已经把烦人的编码问题给解决了，不过我现在还坚持的Python2战线，就针对Python2的编码问题谈谈我的理解（以后简称python）。&lt;/p&gt;

&lt;h3 id=&quot;直接看本质&quot;&gt;直接看本质&lt;/h3&gt;
&lt;p&gt;python中对于一个字符串的表示，不论是什么语言的符号，总的来说有两种方式：字符串对象str和Unicode对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = &quot;test&quot;
&amp;gt;&amp;gt;&amp;gt; type(s)
&amp;lt;type 'str'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; s = u&quot;test&quot;
&amp;gt;&amp;gt;&amp;gt; type(s)
&amp;lt;type 'unicode'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;字符串对象str&lt;/p&gt;

    &lt;p&gt;相当于C++里的string对象，对象维护了一个字节数组，里边存储的就是相应字符串用某一个编码方式编码的结果。可以是GBK，UTF-8等等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unicode对象&lt;/p&gt;

    &lt;p&gt;所有str对象都可以调用decode方法解码成Unicode对象，Unicode对象也可以调用decode编码成str对象，这两个过程中都是要指定编码类型的。解码的结果是否正确取决于指定的编码类型是否正确。相同的字符串的Unicode对象的表示是相同的也是唯一的，但是在不同的编码方式下得到的str对象的表示是不同的：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = [u&quot;测试&quot;, u&quot;测试&quot;.encode(&quot;utf8&quot;), u&quot;测试&quot;.encode(&quot;gbk&quot;)]
&amp;gt;&amp;gt;&amp;gt; print s
[u'\u6d4b\u8bd5', '\xe6\xb5\x8b\xe8\xaf\x95', '\xb2\xe2\xca\xd4']
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;从上边的输出结果也可以看出来gbk编码中文的长度确实要比utf8短。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于str和Unicode对象的具体实现这里留个坑以后在填，最近也在看Python源码分析，看到这部分了再回来补上。&lt;/p&gt;

&lt;h3 id=&quot;需要设置编码的地方&quot;&gt;需要设置编码的地方&lt;/h3&gt;

&lt;p&gt;一个py代码文件有三个编码需要设置：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;文件编码&lt;/p&gt;

    &lt;p&gt;所有的文本文件都是有编码的，python代码文件也是一个文本文件，而且里边如果有中文出现，不管是在注释还是代码中，那么这个文件就是包含中英文字符的文本文件。所以，要指定编码方式来保存代码文件。在Windows中使用IDE或者文本编辑器保存文件会有相应的设置选项来设置文件编码，在Linux上文件保存的编码是由终端的编码决定的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件头编码声明&lt;/p&gt;

    &lt;p&gt;就是在py代码文件头声明的编码，声明的方式有很多种，列举如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# coding=utf8
# coding: gbk
# -*- coding:utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这个编码的我觉得只要是写给python解释器看的，解释器需要知道文件采用的编码才能正确的处理文件，才能正确的读取中文字符。我看到有人总结它的作用：1.声明源文件中将出现非ascii编码，通常也就是中文。2.在高级的IDE中，IDE会将你的文件格式保存成你指定编码格式。3.决定源码中类似于u’哈’这类声明的，解码是选择的解码格式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解释器默认编码&lt;/p&gt;

    &lt;p&gt;其实经常需要设置的是前两个，解释器默认编码我所知道的只有在做编码转换的时候会用到，不过这也是出问题的时候最让人摸不到头脑的地方。
 我们已经知道，一个Unicode对象可以调用encode方法编码成任一种编码的字节码str对象。那么对一个str对象调用encode会进行什么操作呢？会先对其进行decode操作，decode的编码可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sys.getdefaultencoding()&lt;/code&gt;得到，默认是ascii。这就是第二句代码报错的原因。可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sys.setdefaultencoding()&lt;/code&gt;或者显示的指定编码decode再encode来解决这个问题。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u&quot;测试&quot;.encode(&quot;utf8&quot;)
'\xe6\xb5\x8b\xe8\xaf\x95'
&amp;gt;&amp;gt;&amp;gt; &quot;测试&quot;.encode(&quot;utf8&quot;)
Traceback (most recent call last):
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in 	position 0: ordinal not in range(128)
&amp;gt;&amp;gt;&amp;gt; sys.setdefaultencoding(&quot;utf8&quot;)
&amp;gt;&amp;gt;&amp;gt; &quot;测试&quot;.encode(&quot;utf8&quot;)
'\xe6\xb5\x8b\xe8\xaf\x95'
&amp;gt;&amp;gt;&amp;gt; &quot;测试&quot;.decode(&quot;utf8&quot;).encode(&quot;utf8&quot;)
'\xe6\xb5\x8b\xe8\xaf\x95'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;print-乱码的原因&quot;&gt;print 乱码的原因&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;print输出str对象，会把字节数组的内容直接发送的终端输出，所以如果终端编码和字符串的编码不一致的话会出现乱码。&lt;/li&gt;
  &lt;li&gt;print输出Unicode对象，会先调用encode按照终端的编码进行编码，然后发送到终端输出，只要Unicode编码是对的就不会乱码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，用Python操作字符串最好用Unicode。&lt;/p&gt;

&lt;h3 id=&quot;文件读写&quot;&gt;文件读写&lt;/h3&gt;
&lt;p&gt;文本文件本身是有编码的，直接通过open+read读进来的字符串就保存在一个str对象里，编码和文本文件本身的编码是一致的，而不一定跟py代码文件的编码一致。写入文件的时候也是直接把str对象的字节码写入文件，这个地方也是比较迷惑人的。所以在进行文本文件的读写操作时，最好用codec库提供的接口打开文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import codecs
f = codecs.open(&quot;demo.txt&quot;, 'r', 'utf-8')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;打开文件的时候要指定编码方式，read操作读出的直接就是Unicode对象，write写入Unicode对象也会直接encode成open时声明的编码。&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E8%AF%AD%E8%A8%80/%E4%BB%8EPython2%E9%BA%BB%E7%83%A6%E7%9A%84%E7%BC%96%E7%A0%81%E8%AF%B4%E8%B5%B7.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%AF%AD%E8%A8%80/%E4%BB%8EPython2%E9%BA%BB%E7%83%A6%E7%9A%84%E7%BC%96%E7%A0%81%E8%AF%B4%E8%B5%B7.html</guid>
        
        <category>Python</category>
        
        
        <category>语言</category>
        
      </item>
    
      <item>
        <title>朴素贝叶斯在文本分类中的常用模型</title>
        <description>&lt;p&gt;朴素贝叶斯在文本分类中的常用模型主要有两种：多项式模型和伯努利模型&lt;/p&gt;

&lt;h2 id=&quot;概率基础&quot;&gt;概率基础&lt;/h2&gt;
&lt;h3 id=&quot;朴素贝叶斯&quot;&gt;朴素贝叶斯&lt;/h3&gt;
&lt;h3 id=&quot;伯努利分布&quot;&gt;伯努利分布&lt;/h3&gt;
&lt;p&gt;伯努利分布(Bernoulli distribution)又称两点分布，随机变量X的取值只有两个。
&lt;script type=&quot;math/tex&quot;&gt;P\{X=0\}=p,P\{X=1\}=1-p&lt;/script&gt;
伯努利实验是只有两种可能结果的单次随机实验。&lt;/p&gt;
&lt;h3 id=&quot;二项分布&quot;&gt;二项分布&lt;/h3&gt;
&lt;p&gt;二项分布(Binomial distribution)是n重伯努利试验成功次数的离散概率分布。
&lt;script type=&quot;math/tex&quot;&gt;P\{X=k\}=C_n^kp^k(1-p)^{n-k}, k=0,1,2...,n&lt;/script&gt;&lt;/p&gt;
&lt;h3 id=&quot;多项式分布&quot;&gt;多项式分布&lt;/h3&gt;
&lt;p&gt;多项式分布(Multinomial Distribution)是二项式分布的推广。二项式做n次伯努利实验，规定了每次试验的结果只有两个，如果现在还是做n次试验，只不过每次试验的结果可以有多m个，且m个结果发生的概率互斥且和为1，则发生其中一个结果X次的概率就是多项式分布。&lt;/p&gt;
&lt;h2 id=&quot;伯努利模型&quot;&gt;伯努利模型&lt;/h2&gt;

&lt;h2 id=&quot;多项式模型&quot;&gt;多项式模型&lt;/h2&gt;

</description>
        <pubDate>Wed, 19 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%9C%A8%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%9C%A8%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B.html</guid>
        
        
      </item>
    
      <item>
        <title>周报</title>
        <description>&lt;p&gt;说好的每周四的周报，第一周就给忘了…[摊手]，好了，开始第一个周报。&lt;/p&gt;

&lt;p&gt;周二晚上，当我走出NLP的考场的时候，意味着可能我学生生涯的考试已经就此结束了。从此以后，可能就告别了所谓的上课，作业，考勤，考试和学分之类的东西，想想还有点小激动。于是，最近辛勤复习考试的奖励[可能大部分时间是在看剧，顺便复习]，周三周四好好休息了一下。&lt;/p&gt;

&lt;p&gt;下周就要离开雁栖湖了，要回到市里了还是很开心的。不过，要离开这个依山傍水的校园，还有安静舒适的小单间多少还是有点舍不得。这里跟以前的清水河比，偏僻程度有过之而无不及，没有都市的繁华，是一个学习科研的好地方。我没去过欧美的高校，不过美国的大学不是一般都在小镇上吗？会不会跟这里差不多啊，以后有机会一定要去看看。这一年里，由于种种原因，没怎么好好的在这里待着，所以，接下来一周多的时间我希望能慢慢的享受一下在这里的最后的学习生活。坐在窗户旁边，每天都能听到外边有拉着箱子离去的声音，他们可能就要永远离开这个校园了，不知道他们此刻的心情如何呢？&lt;/p&gt;

&lt;h2 id=&quot;上周总结&quot;&gt;上周总结&lt;/h2&gt;
&lt;p&gt;除了复习之外，之前两个周主要在做NLP的大作业，就是实现一个英文单词拼写纠错。这个题目目看起来挺简单的，我在网上找到了一个30行Python代码实现的拼写纠错，非常简洁。但是毕竟是最后一个大作业，我还是想好好做一下，所以找了两篇论文，看一下有没有更好的方法。现在实现的版本基本是宗成庆老师的讲义上边的方法，采用D氏编辑距离作为单词距离的度量，把词典组织成一个trie树，查找候选的过程采用剪枝策略加速。所以，基本的功能已经实现了，接下来要通过找到的两篇论文，一方面尽量做优化改进，另一方面了解更多有关拼写纠错的思路和方法，作为学习。&lt;/p&gt;

&lt;h2 id=&quot;下周计划&quot;&gt;下周计划&lt;/h2&gt;
&lt;h3 id=&quot;拼写纠错&quot;&gt;拼写纠错&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;把论文剩下的部分读完，改进程序。&lt;/li&gt;
  &lt;li&gt;对论文中的方法和思路进行记录总结。&lt;/li&gt;
  &lt;li&gt;完成大作业的文档，同时结合论文的总结写一篇以拼写纠错为主题的博客。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;程序分析的报告&quot;&gt;程序分析的报告&lt;/h3&gt;
&lt;p&gt;夏季学期的课程作业，应该比较水。题目就是选数据流分析、过程间分析、字符串分析、指针分析、符号执行等其中任意一个主题，读论文，写总结。我还是比较感兴趣，抓紧时间了解一下。这个12号之前要交，所以先写这个。&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%91%A8%E6%8A%A5/%E5%91%A8%E6%8A%A5.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%91%A8%E6%8A%A5/%E5%91%A8%E6%8A%A5.html</guid>
        
        <category>周报</category>
        
        
        <category>周报</category>
        
      </item>
    
      <item>
        <title>Python高级写作技巧</title>
        <description>&lt;h3 id=&quot;lambda&quot;&gt;lambda&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo = [1,2,3]
&amp;gt;&amp;gt;&amp;gt; filter(lambda x: x % 3 == 0, foo)
[3]
&amp;gt;&amp;gt;&amp;gt; print map(lambda x: x + 1, foo)
[2, 3, 4]
&amp;gt;&amp;gt;&amp;gt; print reduce(lambda x, y: x + y, foo)
6
&amp;gt;&amp;gt;&amp;gt; print reduce(lambda x, y: x - y, foo)
-4	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;reduce、map和filter都接受一个函数一个函数，一个list，reduce还接受第三个参数作为初始值。&lt;br /&gt;
lambda并不会带来程序运行效率的提高，只会使代码更简洁。&lt;/p&gt;
&lt;h3 id=&quot;list2string&quot;&gt;list2string&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s = &quot;test&quot;
l = list(s)
new_s = ''.join(l)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;排序&quot;&gt;排序&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;l = [(1,2),(2,3),(3,4)]#dict.items()返回这种结构
sorted(l, key=lambda e:e[1], reverse=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;求前n大小值&quot;&gt;求前n大/小值&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import heapq
l = [1,2,3]
heapq.nlargest(n, l)
heapq.nsmallest(n, l)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;删除list的元素&quot;&gt;删除list的元素&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;l = [1,2,3,1,2,3,1]
del[l[-1]] #法1，删掉最后一个元素
l.remove(l[-1]) #法2，删掉第一个值为l[-1]（1）的元素
l.pop() #相当于出栈，删除最后一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 27 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E8%AF%AD%E8%A8%80/Python%E9%AB%98%E7%BA%A7%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%AF%AD%E8%A8%80/Python%E9%AB%98%E7%BA%A7%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7.html</guid>
        
        <category>Python</category>
        
        <category>笔记</category>
        
        
        <category>语言</category>
        
      </item>
    
      <item>
        <title>谈谈软件包管理器</title>
        <description>&lt;p&gt;今天在Mac上用Homebrew的时候突然想到一个问题：Homebrew是个什么东西？为什么可以用他来安装软件？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brew.sh/index_zh-cn.html&quot;&gt;Homebrew&lt;/a&gt;就是一个软件包管理器，我感觉他之于osx就相当于dpkg+apt-get之于Linux Debian。&lt;/p&gt;

&lt;p&gt;Linux不同的发行版有不同的软件包管理器，主要的两个阵营是.deb和.rpm，他们的包管理器分别是dpkg+apt-get和rpm+yum，关于软件包管理器以及dpkg、apt-get、rpm、yum这四个工具的关系可以参考这三篇资料，都比较简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/purgiant/p/3515878.html&quot;&gt;博客一&lt;/a&gt;，讲的非常简洁清楚，而且有比较详细的命令列表，感觉可以作为apt-get等命令使用的辅助文档随时查阅。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://itbilu.com/linux/management/NJ8WlHCmM.html&quot;&gt;博客二&lt;/a&gt;，这篇讲的相对系统一点。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/309113/what-is-the-difference-between-dpkg-and-aptitude-apt-get&quot;&gt;这是一个英文问答社区的答案&lt;/a&gt;，高票答案以时间线的形式模拟了从包管理这个概念产生到高级包管理器产生这个过程，更有利于理解他们的内在关系。同时，我感觉他这种思考和回答问题的方式也是比较有启发意义的。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 24 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linux/%E8%B0%88%E8%B0%88%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html</link>
        <guid isPermaLink="true">http://localhost:4000/linux/%E8%B0%88%E8%B0%88%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html</guid>
        
        <category>linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>浅谈Jekyll</title>
        <description>&lt;p&gt;这里主要是介绍jekyll的结构和使用，默认已经安装好。&lt;/p&gt;
&lt;h2 id=&quot;jekyll是什么&quot;&gt;Jekyll是什么&lt;/h2&gt;
&lt;p&gt;Jekyll是一个基于Ruby的解析引擎，它可以用于将各种模板语言构建成一个静态网站，如templates, partials, liquid, markdown 等。也就是一个简单的类博客形态的静态网站的生产机器。所以，Jekyll的主要工作就是&lt;strong&gt;把一个目录下的文件按照一定的格式和规则生成静态html文件&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;jekyll用到其他技术&quot;&gt;Jekyll用到其他技术&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;YAML&lt;/strong&gt; Jekyll中每一个模板和内容文件都应该有一个YAML格式的文件头，那么YAML是什么呢？它是一种用来写配置文件的语言，如_config.yml就是YAML写的一个配置文件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;markdown和textile&lt;/strong&gt; markdown和textile是一个类型的标记语言，特点是简单易学习，他可以解析成html，由于我主要用的是markdown，所以接下来在内容解析方面我们只讲markdown。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Liquid&lt;/strong&gt; Liquid是一种标记语言，他主要是嵌入html文件中得到模板文件，连接了数据和页面，经过解析之后得到静态的html，然后再加上css和js就得到了最终的博客页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jekyll如何解析文件&quot;&gt;Jekyll如何解析文件&lt;/h3&gt;

&lt;p&gt;Jekyll只是一个解析引擎，他的解析工作主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内容解析&lt;/strong&gt; 通过textile或者markdown实现&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模板解析&lt;/strong&gt; 通过Liquid实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Jekyll traverses your site looking for files to process. Any files with YAML front matter are subject to processing. For each of these files, Jekyll makes a variety of data available via the Liquid templating system. The following is a reference of the available data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;摘自&lt;a href=&quot;http://jekyllrb.com/docs/variables/&quot;&gt;官方文档-variables&lt;/a&gt;，说明Jekyll解析会遍历网站目录找有YAML头的文件处理。我认为处理过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解析yaml头，根据配置做相应处理（如看到layout就在_layout目录下找相应的模板进行合并）&lt;/li&gt;
  &lt;li&gt;遍历文件，根据文件内容，配置以及_config.yml填充Liquid变量&lt;/li&gt;
  &lt;li&gt;解析所有的markdown文件得到html文件&lt;/li&gt;
  &lt;li&gt;解析所有的html文件中的Liquid语法得到最终的html放到_site目录下边&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;jekyll要求的目录结构&quot;&gt;Jekyll要求的目录结构&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;jekyll可以作为服务器吗&quot;&gt;Jekyll可以作为服务器吗&lt;/h2&gt;
&lt;p&gt;Jekyll的核心工作只是一个解析引擎，跟服务器是没有什么关系的，那为什么把Jekyll创建好的博客放到github pages上就可以访问了呢？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Jekyll’s simplified build process with GitHub Pages is one of the biggest advantages of using Jekyll instead of other static site generators. GitHub Pages manages your site’s build process with a single push to your site’s publishing branch. This is Jekyll’s build process for managing your site:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;Push file changes to your pages publishing branch&lt;/li&gt;
    &lt;li&gt;GitHub Pages publishes your site.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;摘自&lt;a href=&quot;https://help.github.com/articles/about-github-pages-and-jekyll/&quot;&gt;github pages的介绍&lt;/a&gt;，github pages是集成了Jekyll的，对于pages的仓库，只要push了新的change，github pages就会用Jekyll引擎重新生成一次，然后再发布。这个发布的实现其实还是github pages本身的服务器实现的，可以是nginx，apache等。所以Jekyll真正的功能应该是和Wordpres在一个层次上，就是把内容和模板转换成网页，只不过wordpress是把内容动态存放在mysql数据库中，而Jekyll是静态的markdown文件。&lt;/p&gt;

&lt;p&gt;Jekyll的程序中集成了开启服务的功能，执行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就可以编译解析当前目录，然后打开4000端口提供web服务，可以作为本地测试的工具。&lt;/p&gt;
&lt;h2 id=&quot;相关资料&quot;&gt;相关资料&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;官网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;官网的中文翻译&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;一个jekyll主题网站&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gohom.win/2015/11/28/Liquid-jekyll/&quot;&gt;基于Jekyll需要讲Liquid语言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/web/%E6%B5%85%E8%B0%88jekyll.html</link>
        <guid isPermaLink="true">http://localhost:4000/web/%E6%B5%85%E8%B0%88jekyll.html</guid>
        
        <category>web</category>
        
        <category>blog</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>新博客开通了</title>
        <description>&lt;h2 id=&quot;关于博客&quot;&gt;关于博客&lt;/h2&gt;
&lt;p&gt;算下来，这已经是第四个博客了。前三个加起来应该也没写多少。:)&lt;/p&gt;

&lt;p&gt;第一个博客应该是大一的时候开通的吧，在cnblogs。当时，应该还在工作室，看别人有博客就自己也开通一个学着写，结果写了没两天就不了了之了。第二个博客是自己写的，在工作室一直写php，后来去学了点html+css就想着自己写一个博客就当练手了。结果写出来了，很简陋，本来也只是一时兴起后来也就没用了。第三个博客是在csdn，这个应该是用的比较长得了，不过到现在也就写了不到十篇文章。当时应该是大三，跟着李林老师学习，博客多少还是记录了一下当时的学习成果。  再后来，因为嫌写博客麻烦，就不怎么写了，平时想记录些什么基本就放在本地或者用作业部落。结果就导致现在作业部落上边记录的东西也不少，可是乱七八糟的，只有几篇是经常看的。&lt;/p&gt;

&lt;h2 id=&quot;recording-and-thinking&quot;&gt;Recording And Thinking&lt;/h2&gt;
&lt;p&gt;我觉得博客这个东西吧，主要的作用是记录，可以记录学习和生活的经历，但更重要的是记录自己的思考。接触过得东西，只是单纯的记录下来，不思考不整理，慢慢地也就丢掉了。&lt;/p&gt;

&lt;p&gt;研一马上就要结束了，不读博的话明年这个时候也要开始找工作了。在百度的经历让我意识到了记录和思考的重要性。过去的这段时间，确实也思考了一些东西，认识到了自己需要改变的地方。以后有类似的想法及时记录下来吧。&lt;/p&gt;

&lt;h2 id=&quot;怎么写&quot;&gt;怎么写&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;每周写一篇周报。&lt;/strong&gt;像在公司的周报一样，但是不是写项目进展。先罗列一下一周做的事情，然后作总结写写这周的收获和感想，最后写一下下周的安排。这样也算是一种时间管理和安排的形式吧。写博客时间的话就定在周四晚上，花一到两个小时的时间，以后回实验室因为有实验室周报的原因可以调整到一起。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每个月至少认真写一篇博客。&lt;/strong&gt;可以是教程，可以是感想，每个月至少写一篇，一定要认真写。不用着急一会儿就写完，三五七八天都可以，一定要保证质量。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;随手记录。&lt;/strong&gt;随手写的笔记也可以放上来，反正平时写笔记都是用的markdown，只是加个YAML头的事。:)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;可能重复做的工作，如果写脚本可以完成的话，而且长远看效率并不低的话为什么不写一个呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;明确目标。&lt;/li&gt;
  &lt;li&gt;分析问题，学会拆解。&lt;/li&gt;
  &lt;li&gt;按部就班，不要浮躁。&lt;/li&gt;
  &lt;li&gt;坚持！坚持！&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E4%BA%86.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E4%BA%86.html</guid>
        
        <category>杂谈</category>
        
        
        <category>杂谈</category>
        
      </item>
    
      <item>
        <title>vim的使用</title>
        <description>&lt;h2 id=&quot;我的vimrc&quot;&gt;我的.vimrc&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set nu
syntax on

&quot; 自定义键映射，方便使用
inoremap jk &amp;lt;Esc&amp;gt;
inoremap vv &amp;lt;Esc&amp;gt;:w&amp;lt;Enter&amp;gt;
nnoremap vv :w&amp;lt;Enter&amp;gt;
inoremap qq &amp;lt;Esc&amp;gt;:wq&amp;lt;Enter&amp;gt;
nnoremap qq :wq&amp;lt;Enter&amp;gt;

set ts=4
set expandtab
set autoindent

&quot; 显示下划线
set cursorline


&quot; Vundle
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'git://github.com/scrooloose/nerdtree.git'
call vundle#end()
&quot; Vundle end

set autochdir
let mapleader=&quot;,&quot;
let NERDTreeChDirMode=2
nnoremap &amp;lt;leader&amp;gt;f :NERDTree .&amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;&amp;lt;Tab&amp;gt; &amp;lt;C-w&amp;gt;

&quot; 打开文件时定位到上次关闭的位置
autocmd BufReadPost *
\ if line(&quot;'\&quot;&quot;)&amp;gt;0&amp;amp;&amp;amp;line(&quot;'\&quot;&quot;)&amp;lt;=line(&quot;$&quot;) |
\ exe &quot;normal g'\&quot;&quot; |
\ endif

&quot; 插入文件头
autocmd BufNewFile *.py,*.sh, exec &quot;:call SetTitle()&quot;
let $author_name = &quot;abelx&quot;
let $author_email = &quot;theabelx@163.com&quot;

func SetTitle()
if &amp;amp;filetype == 'sh'
call setline(1,&quot;\###################################################################&quot;)
call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;))
call append(line(&quot;.&quot;)+1, &quot;\# Author: &quot;.$author_name)
call append(line(&quot;.&quot;)+2, &quot;\# mail: &quot;.$author_email)
call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;))
call append(line(&quot;.&quot;)+4, &quot;\#=============================================================&quot;)
call append(line(&quot;.&quot;)+5, &quot;\#!/bin/bash&quot;)
call append(line(&quot;.&quot;)+6, &quot;&quot;)
else
call setline(1,&quot;\###################################################################&quot;)
call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;))
call append(line(&quot;.&quot;)+1, &quot;\# Author: &quot;.$author_name)
call append(line(&quot;.&quot;)+2, &quot;\# mail: &quot;.$author_email)
call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;))
call append(line(&quot;.&quot;)+4, &quot;\#=============================================================&quot;)
call append(line(&quot;.&quot;)+5, &quot;\#!/usr/bin/python&quot;)
call append(line(&quot;.&quot;)+6, &quot;&quot;)
endif
endfunc
&quot; 插入文件头 end

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;常用命令&quot;&gt;常用命令&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;全文替换&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; :%s/vivian/sky/g
 :1,$s/vivian/sky/g
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查找&lt;/p&gt;

    &lt;p&gt;/，n向后，N向前&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;粘贴时缩进的问题很烦&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; :set paste #粘贴前
 :set nopaste #粘贴后
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示特殊符号&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; :set list
 :set nolist
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;撤销 &amp;amp; 取消撤销&lt;/p&gt;

    &lt;p&gt;u &amp;amp; &amp;lt;C-r&amp;gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;杂记&quot;&gt;杂记&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;hjkl是vim模式的精髓，要慢慢体会。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://easwy.com/blog/archives/advanced-vim-skills-basic-move-method/&quot;&gt;一个讲vim的博客系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%B7%A5%E5%85%B7/vim%E7%9A%84%E4%BD%BF%E7%94%A8.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%B7%A5%E5%85%B7/vim%E7%9A%84%E4%BD%BF%E7%94%A8.html</guid>
        
        <category>vim</category>
        
        <category>linux</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>shell脚本的写法</title>
        <description>&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;
&lt;h3 id=&quot;用户定义变量&quot;&gt;用户定义变量&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var1=&quot;123&quot;
echo $var1
echo &quot;${var1}test&quot;
var2=$var1
$var2=$var1 #不对

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;注意&quot;&gt;注意&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加不加括号都行，括号为了识别变量的边界&lt;/li&gt;
  &lt;li&gt;变量作为左值不加$，作为右值一定要加&lt;/li&gt;
  &lt;li&gt;赋值等号两边不能有空格&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用系统变量&quot;&gt;常用系统变量&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;变量&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$#&lt;/td&gt;
      &lt;td&gt;参数个数，不包括文件名本身&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$0&lt;/td&gt;
      &lt;td&gt;文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$1&lt;/td&gt;
      &lt;td&gt;第一个参数，以此类推&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr1=(1 2 3) #初始化
arr1[0]=1 #赋值，下标范围没有限制
echo ${arr1[1]} #取值
echo ${#arr1[*]} #元素个数

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 单行注释

&quot;
多行
注释
&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;运算符&quot;&gt;运算符&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/linux/linux-shell-basic-operators.html&quot;&gt;菜鸟教程运算符&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;括号&quot;&gt;括号&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tttyd/article/details/11742241&quot;&gt;关于shell中各种括号的解释&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方括号右边和其他字符之间一定要留空格&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ 1 -gt 1 ]
then
  echo 1
fi
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;相关资料&quot;&gt;相关资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.runoob.com/linux/linux-shell.html&quot;&gt;shell菜鸟教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E8%AF%AD%E8%A8%80/shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%86%99%E6%B3%95.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%AF%AD%E8%A8%80/shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%86%99%E6%B3%95.html</guid>
        
        <category>shell</category>
        
        <category>linux</category>
        
        
        <category>语言</category>
        
      </item>
    
  </channel>
</rss>
